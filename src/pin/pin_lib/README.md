# PIN lib

## Mapping New Instructions

One of the challenges of making a simulator capable of running x86-64
applications is figuring out how to appropriately handle all possible
x86-64 instructions that one can encounter. We tried to map a basic
set of commonly encountered x86-64 instructions to Scarab, but it is
extremely likely that you will encounter other unmapped x86-64
instructions. This tutorial shows you how to map these new
instructions to Scarab.

### Unmapped instruction error 

When Scarab encounters an x86-64 instruction that has not been mapped
before, it will produce an error message to the stderr of the frontend
pintool. The error message will read something like this:

`Unmapped instruction at EIP: 400080, opcode: VBLENDPD, category: AVX, opcode index: 827, hasrealrep: 0, is_lock: 0, num_ld: 0, num_st: 0, num_src_regs: 2, num_dst_regs: 1, num_ld1_addr_regs: 0, num_ld2_addr_regs: 0, num_st_addr_regs: 0, num_simd_lanes: 0, lane_width_bytes: 0. Look at README in pin/pin_lib on how to map new instructions`

This is Scarab telling you that it encountered the unmapped x86-64
instruction VBLENDPD, and does not know how to proceed. You need to
add VBLENDPD to the mapping of known x86-64 instructions.

Mapping a new x86-64 instruction requires you to:

1. Determine the corresponding `xed_iclass_enum_t` enum member for the instruction
2. Determine the proper Scarab operate uop type for the instruction
3. Determine the number of SIMD execution lanes, and the width of each lane, for the instruction
4. Determine the proper memory hint for the instruction

### Determining the corresponding `xed_iclass_enum_t` member

We track x86-64 instructions the same way PIN does, as members of the
enum `xed_iclass_enum_t`. For PIN 3.5, the definition of
`xed_iclass_enum_t` is found under
$PIN_ROOT/extras/xed-intel64/include/xed/xed-iclass-enum.h (there is
also another copy for 32-bit x86 under
$PIN_ROOT/extras/xed-ia32/include/xed/xed-iclass-enum.h, but the two
files are identical).

The corresponding `xed_iclass_enum_t` member for an x86-64 instruction
is usually just XED_ICLASS_<INSTRUCTION>. For example, the
corresponding enum member for the VBLENDPD instruction is
`XED_ICLASS_VBLENDPD`. There are some exceptions. For example, some
instructions are represented by a different enum member in the
presence of a LOCK prefix (e.g., `XED_ICLASS_ADD` vs
`XED_ICLASS_ADD_LOCK`). Since right now Scarab does not support
multi-threaded code, we do not do anything special for locked variants
of instructions. There are also (very rarely) other exceptional cases
where a single instruction corresponds to multiple `xed_iclass_enum_t`
enum members. If you encounter one of these cases, you will need to
examine the instruction and consider why PIN/XED decided to split the
instruction into multiple cases.

### Adding to the mapping

Once the corresponding `xed_iclass_enum_t` member for the instruction
is known, we then map it to a struct which contains information that
Scarab uses to process the instruction. The struct, called
`iclass_to_scarab`, is defined in
[src/pin/pin_lib/decoder.cc](../../../src/pin/pin_lib/decoder.cc). The struct consists of four
fields:

* `opcode`
    * the Scarab operate uop type which should be generated for this x86-64 instruction
* `lane_width_bytes`
    * the data width of each execution "lane" for this x86-64 instruction, in bytes
* `num_simd_lanes`
    * the number of execution "lanes" this x86-64 instruction uses; for scalar x86-64 instructions, this is always 1; for SIMD x86-64 instructions, this is the number of SIMD lanes
* `mem_hint`
    * any memory hint (e.g., non-temporal, write-through, etc.) associated with this x86-instruction

To map the new x86-64 instruction, a new `iclass_to_scarab` struct
entry needs to be properly populated, and placed at the index
indicated by the corresponding `xed_iclass_enum_t` member in the array
`iclass_to_scarab_map`. This is done inside
`init_pin_opcode_convert()` in
[src/pin/pin_lib/decoder.cc](../../../src/pin/pin_lib/decoder.cc). The following sections go over
how to do this.

### Determine the Scarab operate uop type

In general, for each x86-64 instruction, Scarab will generate, in this
order:

1. 
   * 0 to 2 load uops, as required
2. 
   * 0 or 1 operate uop, as required
3. 
   * 0 or 1 store uop, as required
4. 
   * 0 or 1 control uop, as required

The logic for generating load, store, and control uops is the same for
all x86-64 instructions, and can be found in `generate_uops()` in
[src/pin/pin_lib/uop_generator.c](../../../src/pin/pin_lib/uop_generator.c).

On the other hand, the operate uop is highly dependent on the
individual x86-64 instruction. Thus, when mapping a new x86-64
instruction to Scarab, one needs to decide which Scarab operate uop
(if any) should be generated by populating the `opcode` field of the
`iclass_to_scarab` struct.

The different possible types of Scarab uops are defined in the
`Op_Type` enum in [src/table_info.h](../../../src/table_info.h). For example, we have
Scarab uops of type `OP_NOP`, `OP_CF`, `OP_MOV`, etc (all the
`Op_Type` enum members have the prefix `OP_` prepended to them). A
brief description of each type of Scarab uop is provided as comments
in the `Op_Type` enum definition.

For performance modeling, the only characteristic that differentiates
the different types of Scarab uops is the execution latency of the
uop. The execution latency of each uop type is defined in
[src/core.param.def](../../../src/core.param.def). For example, the latency of uop type
`OP_IMUL` is defined as the parameter `OP_IMUL_DELAY`, and given the
default value of 3 cycles.

The execution latency for each type of uop is given in cycles, and can
either be a positive integer, or a negative integer. A positive
execution latency indicates that uops of this type can be pipelined,
so even if the execution latency of an individual uop is more than 1
cycle, a new uop of the type can begin execution each cycle to the
same functional unit. On the other hand, a negative execution latency
means uops of that type cannot be pipelined. Operate uops that perform
division like `OP_IDIV` and `OP_FDIV` have a negative execution
latency of -20 by default, meaning each `OP_IDIV` or `OP_FDIV` uop
will occupy its functional unit for 20 cycles and cannot be overlapped
with other uops during execution.

For performance modeling, the only characteristic that matters is the
execution latency of the uop. In this sense one has many choices for
choosing a Scarab operate uop. For example, for a single cycle
pipelined operation, one can equally map the operation to a `OP_NOP`
or a `OP_CMOV` Scarab uop, and for performance modeling purposes the
two choices are equal. However, there are two other considerations to
consider. First, Scarab generates stats on the distribution of
different Scarab uops generated, so it is best to map each x86-64
instruction to the closest matching Scarab operate uop possible. Next,
the choice of Scarab operate uop can affect power modeling: two
different Scarab operate uops with the same execution latency may
behave differently for power modeling. In particular, the McPAT power
modeling tool differentiates between integer and floating point uops,
and uses counts of both as an input. Thus certain operations like
conditional moves or memory have both integer versions and floating
point versions (`OP_CMOV` vs. `OP_FCMOV`, `OP_IMEM` vs. `OP_FMEM`).

#### Generic Scarab operate uop types

For rare/unusual operations, we defined a number of generic Scarab
operate uops that can be mapped to. These are:

* `OP_PIPELINED_FAST`

* `OP_PIPELINED_MEDIUM`

* `OP_PIPELINED_SLOW`

* `OP_NOTPIPELINED_MEDIUM`

* `OP_NOTPIPELINED_SLOW`

* `OP_NOTPIPELINED_VERY_SLOW`

For example, the CPUID instruction is mapped to
`OP_NOTPIPELINED_VERY_SLOW`. We tried to provide a variety of pipelined
and not-pipelined latencies that cover most of the x86-64 instructions we
encountered. However, if for whatever reason you are not satisfied
with any of the existing Scarab uop types, you can always add your own
type.

#### Adding new Scarab uop types

To add a new Scarab uop type, follow these four steps:

1. Add a new member to the `Op_Type` enum in [src/table_info.h](../../../src/table_info.h), by adding a line like this: 
`elem(MY_NEW_OP_TYPE)       /* description of my new op type*/ \`
2. Add a new definition for the execution latency of the new uop type in [src/core.param.def](../../../src/core.param.def), by adding a line like this:
`DEF_PARAM(  op_my_new_op_type_delay,        OP_MY_NEW_OP_TYPE_DELAY,        int,  int,  1,          )`
Be sure to specify a reasonable default latency, and keep in mind the latency should be negative if the uop cannot be pipelined
3. Add a new definition for the stat that will track the number of times the new uop is encountered in [src/inst.stat.def](../../../src/inst.stat.def), with a line like this:
`DEF_STAT(  ST_OP_MY_NEW_OP_TYPE,   COUNT,  NO_RATIO  )`
Make sure that this stat definition is in between the two stats marked as `DIST` - e.g.,
`DEF_STAT(  ST_OP_INV,   DIST,   NO_RATIO  )`
and
`DEF_STAT(  ST_OP_NOTPIPELINED_VERY_SLOW, DIST,    NO_RATIO  )`. 
This tells Scarab that all the stats defined between the two stats (inclusive) form a distribution.
4. Modify `is_fpu_type()`, `is_mul_or_div_type()`, and `is_alu_type()` in [src/exec_ports.c](../../../src/exec_ports.c) as needed. These are used for power modeling purposes for the McPAT power modeling tool.

#### Cases when no operate uop is generated 

There are certain cases when no operate uop is generated. For example
when we have a simple move instruction that loads from memory to
register, or stores from register to memory. In these cases Scarab
will automatically generate the load/store uop required, and will not
generate an operate uop. See `generate_uops()` in
[src/pin/pin_lib/uop_generator.c](../../../src/pin/pin_lib/uop_generator.c) for more details.

#### Resource for determining instruction execution latency

A good resource we used for determining instruction execution latencies
are the instruction tables provided by Agner Fog at
https://www.agner.org/optimize/instruction_tables.pdf.

However, keep in mind that Scarab already generates separate
load/store uops for memory operands, so the latency of accessing
memory operands is already accounted for. To isolate the latency of
just the operate uop, we compare the instruction latency of the
register operands only variants of the instruction to the latency of
variants with memory operands.

### Determining width and number of lanes

For each new x86-64 instruction, we also need to determine the width
of each execution "lane" (`lane_width_bytes` in `iclass_to_scarab`),
and the number of execution "lanes" (`num_simd_lanes` in
`iclass_to_scarab`).

For scalar instructions, the number of execution lanes is always one
(`num_simd_lanes` = 1). For SIMD/vector instructions, the number of
execution lanes is more than one, and depends on both the instruction
and, potentially, the width of the operands.

Similarly, the actual width of each execution "lane" can depend on
both the instruction and the width of the operands, for both scalar and
SIMD instructions. 

For example, there are instructions for which both the width of an
execution lane and the number of lanes can be known from just the
instruction alone. The instruction ADDSD (Add Scalar Double-Precision
Floating-Point Values) always performs a single double-precision
(i.e., 8 bytes) add, regardless of the operands. Thus
`lane_width_bytes` = 8, and `num_simd_lanes` = 1 for ADDSD, always.

However, most of the time you can only know either one of
`lane_width_bytes` or `num_simd_lanes` from the instruction, but not
both. For example, the NOT instruction performs only a single scalar
bitwise-not operation (`num_simd_lanes` = 1), but the width of that
single bitwise-not depends on the actual operands; for example,
`lane_width_bytes` = 1 if the operand is AL, 2 if AX, 4 if EAX, 8 if
RAX.

Conversely, for an SIMD instruction like MULPS (Multiply Packed
Single-Precision Floating-Point Values), `lane_width_bytes` is always
known (single precision, 4 bytes), but `num_simd_lanes` can vary
depending on whether xmm (`num_simd_lanes` = 4), ymm
(`num_simd_lanes` = 8), or zmm registers(`num_simd_lanes` = 16) are used.

For these cases where only one of
{`lane_width_bytes`,`num_simd_lanes`} is known, the other unknown
value should be declared as -1, and at runtime Scarab will deduce the
correct value based on the width of the operand. So, we have:

* for ADDSD
    * `lane_width_bytes` = 8
    * `num_simd_lanes`   = 1
* for NOT
    * `lane_width_bytes` = -1 
    * `num_simd_lanes`   = 1
* for MULPS
    * `lane_width_bytes` = 4 
    * `num_simd_lanes`   = -1

Currently, `lane_width_bytes` and `num_simd_lanes` and not used
internally in Scarab. However, in the future we envision they will be
used for power modeling purposes.

### Determining memory hints 

Finally, instructions like PREFETCHh can come with memory hints like:

* `NT` (non-temporal)
* `T0`
* `T1`
* `T2`

PREFETCHW prefetches data into caches in anticipation of a Write

* `W`

PREFETCHWT1 prefetches vector data into caches with intent to write and T1 hint

* `WT1`

These can be specified to Scarab using the `mem_hint` field of
`iclass_to_scarab`, which specifies the memory hint for the
instruction using the enum `MemHint` (declared in
[src/ctype_pin_inst.h](../../../src/ctype_pin_inst.h)). For most of the other instructions
that do not have memory hints, the `mem_hint` field is set to
`NONE`. Right now Scarab internally does not do anything with the
memory hints, but it could in the future.

There also exist the iclasses `XED_ICLASS_PREFETCH_EXCLUSIVE` and
`XED_ICLASS_PREFETCH_RESERVED`. We added `EXCLUSIVE` and `RESERVED` to
our `MemHint` enum definition for them, but keep in mind Scarab
currently does not support multi-threaded applications.

### Putting it all together

So, in summary, to map a new x86-64 instruction, you need to:

1. Determine the corresponding `xed_iclass_enum_t` enum member for the instruction
2. Determine the proper Scarab operate uop type for the instruction
3. Determine the number of SIMD execution lanes, and the width of each lane, for the instruction
4. Determine the proper memory hint for the instruction

You then create a new `iclass_to_scarab` struct entry and place it at
the index of the corresponding `xed_iclass_enum_t` enum member in the
array `iclass_to_scarab_map`. This is done inside
`init_pin_opcode_convert()` in
[src/pin/pin_lib/decoder.cc](../../../src/pin/pin_lib/decoder.cc). Here are some examples for some
of the instructions we've talked about in this tutorial:

`iclass_to_scarab_map[XED_ICLASS_ADD] = {OP_IADD, -1, 1, NONE};`

`iclass_to_scarab_map[XED_ICLASS_ADDSD] = {OP_FADD, 8, 1, NONE};`

`iclass_to_scarab_map[XED_ICLASS_ADD_LOCK] = {OP_IADD, -1, 1, NONE};`

`iclass_to_scarab_map[XED_ICLASS_CPUID] = {OP_NOTPIPELINED_VERY_SLOW, -1, 1, NONE};`

`iclass_to_scarab_map[XED_ICLASS_MULPS] = {OP_FMUL, 4, -1, NONE};`

`iclass_to_scarab_map[XED_ICLASS_NOT] = {OP_LOGIC, -1, 1, NONE};`

`iclass_to_scarab_map[XED_ICLASS_PREFETCHNTA] = {OP_MOV, -1, 1, NT};`

`iclass_to_scarab_map[XED_ICLASS_PREFETCHT0] = {OP_MOV, -1, 1, T0};`

`iclass_to_scarab_map[XED_ICLASS_PREFETCHT1] = {OP_MOV, -1, 1, T1};`

`iclass_to_scarab_map[XED_ICLASS_PREFETCHT2] = {OP_MOV, -1, 1, T2};`

`iclass_to_scarab_map[XED_ICLASS_PREFETCHW] = {OP_MOV, -1, 1, W};`

`iclass_to_scarab_map[XED_ICLASS_PREFETCHWT1] = {OP_MOV, -1, 1, WT1};`

`iclass_to_scarab_map[XED_ICLASS_VBLENDPD] = {OP_CMOV, 8, -1, NONE};`

Note the initializations inside `init_pin_opcode_convert()` are in
alphabetical order.


